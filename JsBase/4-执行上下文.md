# 执行上下文

JavaScript 引擎（V8）运行时，并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，这个准备工作是一个抽象的对象我们通常把他叫做执行上下文(execution contexts)

执行上下文总共有三种类型：

- **全局执行上下文：** 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 `this` 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
- **函数执行上下文：** 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
- **Eval 函数执行上下文：** 运行在 `eval` 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。

执行上下文的两个阶段

- 创建（也就是下文7中的**预编译**）
- 执行

### 执行上下文栈

函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？

JavaScript 引擎创建了执行上下文栈来管理执行上下文。**可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则**。

<p style="color:red;font-weight:bold">注意点：</p>

- JavaScript 执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
- <font color="red">每当进入一个函数的执行就会创建函数的执行上下文</font>，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。(记住一定是执行之前会创建，不执行不会创建，下面有例子说明)
- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。

**example**

```js
var a=1
function fn1(){
    console.log(a)
    var fn2=()=>{
        console.log("fn2")
    }
    fn2()
}
fn1()
```

- 首先创建全局上下文放入栈顶
- 然后执行fn1之前，创建fn1的执行上下文，将其放入栈顶
- 执行fn1，在执行fn2之前，创建fn2的执行上下文，将其放入栈顶
- fn2执行完毕，将其从栈顶弹出
- fn1执行完毕，将其从栈顶弹出



最后我们看个闭包的例子

```js
function fn1(){
    let count=0;
    var fn2=()=>{
        console.log(count++)
    }
    return fn2
}
fn1()()
```

- 首先创建全局上下文放入栈顶
- 然后fn1()说明要执行fn1，此时创建fn1的执行上下文，放入栈顶 (push)
- 执行完毕之后，弹出fn1，但并没有被销毁 (pop)
- 然后fn1()()说明要执行fn2，此时创建fn2的执行上下文，放入栈顶 (push)
- 执行完毕之后，弹出fn2 (pop)

这里有个注意点就是步骤三，并没有先创建fn2的执行上下文，因为此时fn2并没有要执行。



[参考掘金博客](<https://juejin.im/post/58eaecdea0bb9f0069271861>)

