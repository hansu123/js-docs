# 闭包

### 1. 闭包有什么特点

- 定义在函数内部的函数
- 能访问包含其函数的变量
- 即使函数执行完，闭包外部的变量也没有被回收

### 2. 对闭包的理解

函数作用域取决于创建时，而不是调用时。在我们调用函数之前已经保存了一条作用域链。

比如全局变量->外层函数的变量->内层函数的变量这条作用域链。

而当我们调用该函数的时候，会创建一个对象去保存这些变量，比如你要z传入的参数..,并将创建的对象放到之前创建好的作用域链中，因为你每次调用可能会传入不同的参数所以每次都会形成新的作用域链。

### 3. 原理

记得以前我们通常会遇到一个经典的题目

```
var data = [];

for (var i = 0; i < 4; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

可能刷过面试题的都知道，答案是4,4,4但是你知道为什么会这样吗？它的本质究竟是什么？

ok我们一步步来揭开谜底

- 创建GO

```
GO:{
    data:undefined,
    i:undefined
}
```

- 执行

```
GO:{
    i:4,
    data:[xxx]
}
```

- 执行`data[0]()`先创建上下文

```
data[0].AO{

}
```

并创建作用域

`data[0].[[scope]] = [data[0].AO，外部的GO];`

- 执行

因为AO中并没有i，所以会去GO中找，此时i是4，所以打印为4

同理下面两个也是4

...

如何达到我们想要的结果呢？细心的我们会发现，子所以是因为变成4，是因为我们函数自身AO中没有i，需要去外部的GO寻找i，但此时的i已经变成4,4,4，所以我们只要想办法能将每次循环的i保留即可。

- 闭包

我们看看闭包怎么实现

```
var data = [];

for (var i = 0; i < 4; i++) {
  data[i] = (function(i){
    return function () {
    console.log(i);
    }
  })(i)
}

data[0]();
data[1]();
data[2]();
```

于是变成了这样

- 创建GO

```
GO:{
    data:undefined,
    i:undefined
}
```

- 执行

i自增，但是循环内部有函数执行，所以要创建上下文

- 执行匿名函数先创建上下文

```
匿名函数.AO{
  i:0
}
```

并创建作用域

`匿名函数.[[scope]] = [匿名函数.AO，外部的GO];`

ok，以此类推，还有三个匿名函数也有一样，全部执行完毕

```
GO:{
    i:4,
    data:[f,f,f,f]
}
```

- 好开始执行data[0]，先创建函数上下文

```
data[0].AO:{
    
}
```

并创建作用域

`data[0].[[scope]] = [data[0].AO,匿名函数.AO，外部的GO];`

我们发现与之前唯一的区别是多了一层作用域，因为内部AO没有i，所以去匿名函数的AO寻找，发现i为0，于是结果就是0，以此类推结果为0,1,2,3

[参考掘金博客](<https://juejin.im/post/590159d8a22b9d0065c2d918>)



### 4. 使用场景

####  4.1 计数器

```javascript
var num=0;
function count(){
var num=1;
return function(){
console.log(num++);  
}  
}
let fn=count();
fn(); //1
fn(); //2
```

- 解释下这个题目，很多会觉得第一个答案应该是0

首先我在上面已经说了函数作用域取决于创建时，而不是调用时。

创建时的作用域是全局作用域num->外层函数局部作用域num

所以在调用时会先去找外层局部函数的作用域(如果没有外层的num=1),此题结果就是0,1

- 为什么第二次调用就变成了2呢？

因为上面已经说了，每次调用函数都会创建一个对象去保存当前的变量，所以前一次调用的num会被一直保存在新创建的对象中，不会被销毁。

可以理解为，第二次fn()的作用域链是 全局的num=0->内层num=1->创建对象中的num=2,因为num=2近所以num值为2.

#### 4.2 循环添加点击事件

```javascript
for(var i=0;i<10;i++){
btns[i].onclick=function(){
alert(i);
}
}
```

这个题也很好理解就是给每一个btn绑定点击事件，但是最后点击发现都是10.因为循环完毕之后调用i，i的值已经变成了10。

利用闭包可以解决，我们上面说了闭包每次调用时都会创建一个对象去保存私有变量，所以这个私有变量并不会被销毁，因为是一次调用创建一次，所以每个对象彼此是独立的不会相互影响。这样就可以将i值保存。

```
for(var i=0;i<10;i++){
btns[i].onclick=(function(){
alert(i);
}(i))
}
```

