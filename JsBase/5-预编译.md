# 预编译（变量对象VO）

如上文所说，执行上下文有两个阶段，创建和执行，每个执行上下文都用有自己的变量对象，全局的就叫做全局对象自身，那函数里的就叫做活动对象（AO）

### 1. 函数上下文创建阶段：

在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色。

创建阶段需要做以下几点：

- 创建**变量对象**：首先初始化函数的参数 arguments，提升函数声明和变量声明。下文会详细说明。
- 创建**作用域链**（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
- 确定**this 指向**：包括多种情况，下文会详细说明。

### 2. 函数执行阶段：

**example**

```js
console.log(a)
var a=1
function a(b){
    console.log("a")
}
var c=(b)=>{
    console.log(a)
    a=12
    console.log(b)
}
c(1)
```



**GO**:

前面说过，js是解释型语言，一开始需要创建一个全局的执行上下文环境，可以理解为window对象，也可以理解为GO（Global Object）对象。将所有声明的全局变量、未使用var和let声明的变量放到GO对象中，并且赋值为undefined；然后再将所有的函数声明也放到GO对象中，并且赋值为函数自身的函数体。

比如上面的例子，一开始就会创建如下的GO

预编译时GO，先把所有未使用var和let声明的变量放进来

```
GO:{
 a:undefined
}
```

然后再将所有的函数声明也放到GO对象中，并且赋值为函数自身的函数体。

```js
GO:{
 a:function (){console.log("a")},//如果变量对象已经存在相同名称的属性，则完全替换这个属性（函数声明优先级高，但是后续可以继续赋值）
 c:undefined
}
```

开始执行代码

```js
console.log(a) //打印出函数
-----
a=1
=>
GO:{
    a:1,
    c:function(){console.log(a)}//将c赋值成函数
}
-----
c(1)
//开始执行c
```



执行c的之前又会发生预编译

AO:

预编译时，变量对象会包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明(函数声明优先级最高)
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明(变量名不会覆盖函数名，因为函数名优先级更高)
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

依靠上面，我们制定四部曲

1. 创建AO活动对象（Active Object）
2. 查找**形参**和**变量声明**，值赋予undefined；
3. 实参值赋给形参；
4. 查找函数声明，值赋予函数体；



**于是执行函数c()之前，发生预编译** AO

```js
AO:{
  b:undefined
}
```

=>

```js
AO:{
  b:1
}
```

执行代码，

```js
console.log(a)，此时c中没有a，所以去GO中找，拿到a等于1
-----
a=12
=>
GO:{
  a:12
}
-----
console.log(b),看AO中的b为1，所以打印为1
```

[参考博客](https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html>)

[参考掘金博客](<https://juejin.im/post/58ec3cc944d90400576a2cdc>)

