# JS函数基本概要



### 一.函数

#### 1.简述变量声明提前

函数声明时会将所有变量提升到当前作用域最顶端，将变量的初始换留在原来位置。

#### 2.简述函数的调用

* 作为普通函数调用 fn()
* 作为构造函数调用 new Fn()
* 作为对象的方法调用 obj.fn()
* call和apply调用 fn.call(...)

函数作用域取决于创建时，而不是调用时

#### 3.简述this的四种用法

* 作为普通函数 this->window
* 在构造函数中指代实例对象 this.name=name
* 在对象中的方法要访问对象属性时 sing:function(){console.log(this.name)}
* call和apply调用时 call(this,.....)

this的指向取决于调用时，而不是创建时

#### 4.简述函数作用域和作用域链

##### 4.1函数作用域

变量在声明它的这个函数以及在这个函数体内嵌套的任何函数内都是可见的，但是在这个函数体外部是不可见的。

##### 4.2作用域链

就是想要使用某一变量会先去当前作用域寻找该变量，如果找不到则会去上一层作用域寻找，直至找到为止。

#### 5.函数的命名空间

其实就是匿名函数的自调用,目的是不污染全局变量

```javascript
(function(){  
}())
```

#### 6.简要聊一下闭包

可以访问函数内部变量的函数

##### 6.1闭包有什么特点

* 定义在函数内部的函数
* 能访问包含其函数的变量
* 即使函数执行完，闭包外部的变量也没有被回收

##### 6.2你对闭包的理解

函数作用域取决于创建时，而不是调用时。在我们调用函数之前已经保存了一条作用域链。

比如全局变量->外层函数的变量->内层函数的变量这条作用域链。

而当我们调用该函数的时候，会创建一个对象去保存这些变量，比如你要z传入的参数..,并将创建的对象放到之前创建好的作用域链中，因为你每次调用可能会传入不同的参数所以每次都会形成新的作用域链。

##### 6.3说说闭包使用场景

###### 6.3.1 计数器

```javascript
var num=0;
function count(){
var num=1;
return function(){
console.log(num++);  
}  
}
let fn=count();
fn(); //1
fn(); //2
```

* 解释下这个题目，很多会觉得第一个答案应该是0

首先我在上面已经说了函数作用域取决于创建时，而不是调用时。

创建时的作用域是全局作用域num->外层函数局部作用域num

所以在调用时会先去找外层局部函数的作用域(如果没有外层的num=1),此题结果就是0,1

* 为什么第二次调用就变成了2呢？

因为上面已经说了，每次调用函数都会创建一个对象去保存当前的变量，所以前一次调用的num会被一直保存在新创建的对象中，不会被销毁。

可以理解为，第二次fn()的作用域链是 全局的num=0->内层num=1->创建对象中的num=2,因为num=2近所以num值为2.

###### 6.3.2 循环添加点击事件

```javascript
for(var i=0;i<10;i++){
btns[i].onclick=function(){
alert(i);
}
}
```

这个题也很好理解就是给每一个btn绑定点击事件，但是最后点击发现都是10.因为循环完毕之后调用i，i的值已经变成了10。

利用闭包可以解决，我们上面说了闭包每次调用时都会创建一个对象去保存私有变量，所以这个私有变量并不会被销毁，因为是一次调用创建一次，所以每个对象彼此是独立的不会相互影响。这样就可以将i值保存。

```
for(var i=0;i<10;i++){
btns[i].onclick=(function(){
alert(i);
}(i))
}
```

#### 6.3.3 模块化封装

```javascript
function count(){
var num=1;
return {
addNum:function(){console.log(num++)},
redNum:function(){console.log(num--)}
}
}
let fn1=count().addNum;
let fn2=count().redNum;
fn1(); //1
fn2(); //1
```

这个题目也很经典，其实还是上面所说的，函数调用时都会自己形成一个新的作用域链。彼此不会产生影响。

#### 6.3.4谈谈闭包的缺点-内存泄漏

内存垃圾回收的策略是看看每个值的引用计数是否为0.

所以当A对象包含B,B包含A时会发生循环引用也就是常说的内存泄漏

比如


