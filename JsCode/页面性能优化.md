# 页面性能优化

### 一.减少http请求

* 压缩资源
* 使用雪碧图
* ​

### 二.非核心代码的异步加载

js解析是自上而下的同步任务，解析到`<script>`标签呢，如果文件过大可能会引起阻塞，影响接下来的页面解析，所以现在通常的做法是把js文件放在body的最后，或者使用异步加载的方法。

#### 1.异步加载的方式

##### 1.1 动态创建脚本加载

```
var script=document.createElement("script");
script.src="";
document.body.appendChild(script);
```

##### 1.2 defer

html解析完之后执行，如果是多个，按照加载的顺序依次执行。

```html
<head>
..
<script src="./1.js" defer></script>
</head>
```

这样就是在html解析完之后再去解析js文件

##### 1.3 async

是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

这个和defer的主要区别是

### 三.利用浏览器缓存

缓存：资源文件在浏览器中存在的备份。

#### 1.强缓存

当页面第一次请求服务器时，服务器会将资源存储在本地磁盘中，下一次在请求服务器时，浏览器会检查是否命中强缓存，如果命中强缓存，则不会请求服务器，直接在缓存中读取资源，响应的状态码依然是200.

##### 1.1 expires:(http1.0)

过期时间，绝对时间,下发的是服务器的时间，但是比较的时候是客户端的时间。

##### 1.2 cache-control:(http1.1)

 max-age=3600 客户端响应时间，拿到资源之后3600后失效

如果两者都有，以后者为准

原理：以上两个都是加在第一次请求的头部，当第一次接受到响应之后会把资源和请求头部一起放在本地缓存中，第二次请求时会去寻找这个头部，并计算时间有没有过期，没有过期直接读取本地缓存中的资源。

##### 1.3 如何设置 

`res.setHeader("Cache-Control","public,max-age=120");`



#### 2.协商缓存

##### 2.1 Last-Modified和if-modified-since

第一次请求时，服务器会返回相应的资源，并会在响应头部携带一个叫做last-modified的东西，告诉浏览器这是服务器最后一次修改的时间。下一次呢，浏览器再次请求服务器的时候，会在请求头部添加一个if-modified-since，这个值就是第一次返回的last-modified，服务器接受到这个值就会去跟资源最后一次修改的时间做对比，如果一致，返回304，意思是资源没有发生改变，我不返回资源给你，你直接从自己的缓存里下吧。

##### 2.2 Etag和if-None-Match

有时候我们只是改变文件，但是文件内容并未被修改的时候，如何判断呢？就需要上面这两个，其实和之前一样，只不过这个是携带一个唯一标识etag，如果一致，返回304，意思是资源没有发生改变，我不返回资源给你，你直接从自己的缓存里下吧。

四.使用cdn



五.预解析DNS

`<meta http-equiv="x-dns-prefetch-control" content="on">`

`<link rel="dns-prefetch" href="">`